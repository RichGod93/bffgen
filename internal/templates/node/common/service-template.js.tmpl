/**
 * {{.ServiceName}} Service
 * Auto-generated by bffgen
 * 
 * Handles communication with {{.ServiceName}} backend service
 */

const HttpClient = require('./httpClient');
const logger = require('../utils/logger');

class {{.ServiceNamePascal}}Service {
  constructor() {
    this.baseURL = process.env.{{.EnvKey}}_URL || '{{.BaseURL}}';
    this.client = new HttpClient(this.baseURL, {
      timeout: parseInt(process.env.{{.EnvKey}}_TIMEOUT) || 30000,
      retries: parseInt(process.env.{{.EnvKey}}_RETRIES) || 3
    });
  }

{{range .Endpoints}}
  /**
   * {{.Method}} {{.BackendPath}}
   * {{if .Description}}{{.Description}}{{end}}
   */
  async {{.HandlerName}}(params = {}, query = {}, body = null, headers = {}) {
    try {
      // Build path with params
      let path = '{{.BackendPath}}';
      Object.keys(params).forEach(key => {
        path = path.replace(`:${key}`, params[key]);
      });

      // Add query string
      const queryString = new URLSearchParams(query).toString();
      if (queryString) {
        path += `?${queryString}`;
      }

      // Forward authorization header if present
      const requestHeaders = {};
      if (headers.authorization || headers.Authorization) {
        requestHeaders.Authorization = headers.authorization || headers.Authorization;
      }

      // Make request based on method
      let result;
      switch ('{{.Method}}') {
        case 'GET':
          result = await this.client.get(path, { headers: requestHeaders });
          break;
        case 'POST':
          result = await this.client.post(path, body, { headers: requestHeaders });
          break;
        case 'PUT':
          result = await this.client.put(path, body, { headers: requestHeaders });
          break;
        case 'PATCH':
          result = await this.client.patch(path, body, { headers: requestHeaders });
          break;
        case 'DELETE':
          result = await this.client.delete(path, { headers: requestHeaders });
          break;
        default:
          throw new Error(`Unsupported HTTP method: {{.Method}}`);
      }

      logger.debug(`{{$.ServiceName}}.{{.HandlerName}} completed successfully`);
      return result;
    } catch (error) {
      logger.error(`{{$.ServiceName}}.{{.HandlerName}} failed:`, {
        error: error.message,
        status: error.status,
        params,
        query
      });
      
      // Transform backend errors to standardized format
      const serviceError = new Error(error.message || 'Backend service error');
      serviceError.status = error.status || 500;
      serviceError.service = '{{$.ServiceName}}';
      serviceError.operation = '{{.HandlerName}}';
      serviceError.originalError = error;
      
      throw serviceError;
    }
  }
{{end}}
}

module.exports = {{.ServiceNamePascal}}Service;

