const { GraphQLError } = require('graphql');
const logger = require('./utils/logger');

/**
 * GraphQL Resolvers for {{.ProjectName}} BFF
 * Generated by bffgen
 */

const resolvers = {
  Query: {
    health: () => ({
      status: 'healthy',
      timestamp: new Date(),
      version: process.env.npm_package_version || '1.0.0',
    }),

    me: async (_, __, { user, dataSources }) => {
      if (!user) {
        throw new GraphQLError('Not authenticated', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      try {
        return await dataSources.userService.getUserById(user.id);
      } catch (error) {
        logger.error('Error fetching user:', error);
        throw new GraphQLError('Failed to fetch user', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },

    userDashboard: async (_, { userId }, { user, dataSources }) => {
      if (!user) {
        throw new GraphQLError('Not authenticated', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      try {
        // Parallel aggregation from multiple microservices
        const [userData, activities, notifications, stats] = await Promise.all([
          dataSources.userService.getUserById(userId),
          dataSources.activityService.getRecentActivity(userId),
          dataSources.notificationService.getNotifications(userId),
          dataSources.analyticsService.getUserStats(userId),
        ]);

        return {
          user: userData,
          recentActivity: activities,
          notifications: notifications,
          stats: stats,
        };
      } catch (error) {
        logger.error('Error fetching user dashboard:', error);
        throw new GraphQLError('Failed to fetch user dashboard', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },

    {{range .BackendServices}}
    {{.Name}}: async (_, __, { dataSources }) => {
      try {
        return await dataSources.{{.Name}}Service.getData();
      } catch (error) {
        logger.error('Error fetching {{.Name}} data:', error);
        throw new GraphQLError('Failed to fetch {{.Name}} data', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },
    {{end}}
  },

  Mutation: {
    updateUser: async (_, { input }, { user, dataSources }) => {
      if (!user) {
        throw new GraphQLError('Not authenticated', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      try {
        return await dataSources.userService.updateUser(user.id, input);
      } catch (error) {
        logger.error('Error updating user:', error);
        throw new GraphQLError('Failed to update user', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },
  },

  Subscription: {
    notificationAdded: {
      subscribe: (_, { userId }, { pubsub }) => {
        return pubsub.asyncIterator([`NOTIFICATION_${userId}`]);
      },
    },
  },

  // Custom scalar resolvers
  DateTime: {
    parseValue(value) {
      return new Date(value);
    },
    serialize(value) {
      return value instanceof Date ? value.toISOString() : value;
    },
    parseLiteral(ast) {
      if (ast.kind === 'StringValue') {
        return new Date(ast.value);
      }
      return null;
    },
  },

  JSON: {
    parseValue(value) {
      return value;
    },
    serialize(value) {
      return value;
    },
    parseLiteral(ast) {
      switch (ast.kind) {
        case 'StringValue':
          return ast.value;
        case 'IntValue':
          return parseInt(ast.value, 10);
        case 'FloatValue':
          return parseFloat(ast.value);
        case 'BooleanValue':
          return ast.value;
        case 'ObjectValue':
          return ast.fields.reduce((obj, field) => {
            obj[field.name.value] = resolvers.JSON.parseLiteral(field.value);
            return obj;
          }, {});
        case 'ListValue':
          return ast.values.map((value) => resolvers.JSON.parseLiteral(value));
        default:
          return null;
      }
    },
  },
};

module.exports = resolvers;
