const { GraphQLError } = require('graphql');
const logger = require('./utils/logger');

const startTime = Date.now();

/**
 * GraphQL Resolvers for {{.ProjectName}} BFF (GraphQL Yoga)
 * Generated by bffgen
 */

const resolvers = {
  Query: {
    health: () => ({
      status: 'healthy',
      timestamp: new Date(),
      version: process.env.npm_package_version || '1.0.0',
      uptime: (Date.now() - startTime) / 1000,
    }),

    me: async (_, __, context) => {
      if (!context.user) {
        throw new GraphQLError('Not authenticated', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      try {
        return await context.dataSources.userService.getUserById(context.user.id);
      } catch (error) {
        logger.error('Error fetching user:', error);
        throw new GraphQLError('Failed to fetch user data', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },

    dashboard: async (_, { userId }, context) => {
      if (!context.user) {
        throw new GraphQLError('Not authenticated', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      try {
        // Parallel aggregation from multiple services
        const [user, activities, notifications, summary] = await Promise.all([
          context.dataSources.userService.getUserById(userId),
          context.dataSources.activityService.getRecentActivities(userId, 10),
          context.dataSources.notificationService.getNotifications(userId),
          context.dataSources.analyticsService.getSummary(userId),
        ]);

        return {
          user,
          summary,
          recentActivities: activities,
          notifications,
        };
      } catch (error) {
        logger.error('Error fetching dashboard:', error);
        throw new GraphQLError('Failed to fetch dashboard data', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },

    {{range .BackendServices}}
    {{.Name}}Data: async (_, __, context) => {
      try {
        const data = await context.dataSources.{{.Name}}Service.getData();
        return {
          id: '{{.Name}}',
          status: 'active',
          data,
          updatedAt: new Date(),
        };
      } catch (error) {
        logger.error('Error fetching {{.Name}} data:', error);
        throw new GraphQLError('Failed to fetch {{.Name}} data', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },

    {{.Name}}Items: async (_, { first, after, filter }, context) => {
      try {
        const result = await context.dataSources.{{.Name}}Service.getItems({
          limit: first,
          cursor: after,
          filter,
        });

        return {
          edges: result.items.map((item, index) => ({
            node: item,
            cursor: Buffer.from(`${item.id}`).toString('base64'),
          })),
          pageInfo: {
            hasNextPage: result.hasMore,
            hasPreviousPage: !!after,
            startCursor: result.items.length > 0
              ? Buffer.from(`${result.items[0].id}`).toString('base64')
              : null,
            endCursor: result.items.length > 0
              ? Buffer.from(`${result.items[result.items.length - 1].id}`).toString('base64')
              : null,
            totalCount: result.total || result.items.length,
          },
        };
      } catch (error) {
        logger.error('Error fetching {{.Name}} items:', error);
        throw new GraphQLError('Failed to fetch {{.Name}} items', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },
    {{end}}
  },

  Mutation: {
    updateProfile: async (_, { input }, context) => {
      if (!context.user) {
        throw new GraphQLError('Not authenticated', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      try {
        return await context.dataSources.userService.updateUser(context.user.id, input);
      } catch (error) {
        logger.error('Error updating profile:', error);
        throw new GraphQLError('Failed to update profile', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },

    markNotificationRead: async (_, { id }, context) => {
      if (!context.user) {
        throw new GraphQLError('Not authenticated', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      try {
        return await context.dataSources.notificationService.markAsRead(id);
      } catch (error) {
        logger.error('Error marking notification as read:', error);
        throw new GraphQLError('Failed to mark notification as read', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },

    {{range .BackendServices}}
    create{{.Name | ToPascalCase}}Item: async (_, { input }, context) => {
      if (!context.user) {
        throw new GraphQLError('Not authenticated', {
          extensions: { code: 'UNAUTHENTICATED' },
        });
      }

      try {
        return await context.dataSources.{{.Name}}Service.createItem(input);
      } catch (error) {
        logger.error('Error creating {{.Name}} item:', error);
        throw new GraphQLError('Failed to create {{.Name}} item', {
          extensions: { code: 'INTERNAL_SERVER_ERROR' },
        });
      }
    },
    {{end}}
  },

  Subscription: {
    notificationAdded: {
      subscribe: (_, { userId }, context) => {
        // Implement subscription logic (e.g., with Redis pub/sub or GraphQL subscriptions)
        // This is a placeholder - you'll need to implement your subscription mechanism
        return context.pubsub.asyncIterator([`NOTIFICATION_${userId}`]);
      },
    },

    activityAdded: {
      subscribe: (_, { userId }, context) => {
        return context.pubsub.asyncIterator([`ACTIVITY_${userId}`]);
      },
    },
  },

  // Custom scalar resolvers
  DateTime: {
    serialize(value) {
      return value instanceof Date ? value.toISOString() : value;
    },
    parseValue(value) {
      return new Date(value);
    },
    parseLiteral(ast) {
      if (ast.kind === 'StringValue') {
        return new Date(ast.value);
      }
      return null;
    },
  },

  JSON: {
    serialize(value) {
      return value;
    },
    parseValue(value) {
      return value;
    },
    parseLiteral(ast) {
      switch (ast.kind) {
        case 'StringValue':
        case 'BooleanValue':
          return ast.value;
        case 'IntValue':
        case 'FloatValue':
          return parseFloat(ast.value);
        case 'ObjectValue':
          return ast.fields.reduce((obj, field) => {
            obj[field.name.value] = resolvers.JSON.parseLiteral(field.value);
            return obj;
          }, {});
        case 'ListValue':
          return ast.values.map(value => resolvers.JSON.parseLiteral(value));
        default:
          return null;
      }
    },
  },
};

module.exports = resolvers;
