// Generated Fastify BFF server for {{.ProjectName}}
require('dotenv').config();
const fastify = require('fastify')({ 
  logger: {
    level: process.env.LOG_LEVEL || 'info',
    transport: process.env.NODE_ENV === 'development' ? {
      target: 'pino-pretty',
      options: {
        translateTime: 'HH:MM:ss Z',
        ignore: 'pid,hostname'
      }
    } : undefined
  }
});

const PORT = process.env.PORT || 8080;

// Register plugins
async function start() {
  try {
    // CORS configuration
    const corsOrigins = process.env.CORS_ORIGINS 
      ? process.env.CORS_ORIGINS.split(',') 
      : {{.CORSOriginsJS}};

    await fastify.register(require('@fastify/cors'), {
      origin: corsOrigins,
      credentials: true,
      methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
      allowedHeaders: ['Accept', 'Authorization', 'Content-Type', 'X-CSRF-Token', 'X-Requested-With'],
      exposedHeaders: ['X-CSRF-Token']
    });

    // Security headers
    await fastify.register(require('@fastify/helmet'), {
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", "data:", "https:"],
          fontSrc: ["'self'"],
          connectSrc: ["'self'"],
          frameAncestors: ["'none'"]
        }
      }
    });

    // Rate limiting
    await fastify.register(require('@fastify/rate-limit'), {
      max: parseInt(process.env.RATE_LIMIT) || 100,
      timeWindow: '15 minutes',
      cache: 10000,
      allowList: ['127.0.0.1'],
      redis: process.env.REDIS_URL ? require('ioredis').createClient(process.env.REDIS_URL) : undefined
    });

    // Cookie support
    await fastify.register(require('@fastify/cookie'), {
      secret: process.env.COOKIE_SECRET || 'change-this-secret-in-production',
      parseOptions: {}
    });

    // JWT support (optional)
    if (process.env.JWT_SECRET) {
      await fastify.register(require('@fastify/jwt'), {
        secret: process.env.JWT_SECRET,
        cookie: {
          cookieName: 'token',
          signed: false
        }
      });
    }

    // Request logging hook
    fastify.addHook('onRequest', async (request, reply) => {
      request.startTime = Date.now();
    });

    fastify.addHook('onResponse', async (request, reply) => {
      const duration = Date.now() - request.startTime;
      request.log.info({
        method: request.method,
        url: request.url,
        statusCode: reply.statusCode,
        duration: `${duration}ms`
      });
    });

    // Health check endpoint
    fastify.get('/health', async (request, reply) => {
      return { 
        status: 'healthy', 
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        environment: process.env.NODE_ENV || 'development'
      };
    });

    // Readiness check endpoint
    fastify.get('/ready', async (request, reply) => {
      // Add checks for database, redis, etc.
      return { status: 'ready', timestamp: new Date().toISOString() };
    });

    // Liveness check endpoint
    fastify.get('/live', async (request, reply) => {
      return { status: 'alive', timestamp: new Date().toISOString() };
    });

    // Auth endpoints placeholder
    fastify.post('/api/auth/login', {
      schema: {
        body: {
          type: 'object',
          required: ['email', 'password'],
          properties: {
            email: { type: 'string', format: 'email' },
            password: { type: 'string', minLength: 6 }
          }
        }
      }
    }, async (request, reply) => {
      const { email, password } = request.body;
      
      // NOTE: Replace this with your actual authentication logic
      // Example: verify credentials against database
      // const user = await UserModel.findOne({ email });
      // const isValid = await bcrypt.compare(password, user.passwordHash);
      // if (!isValid) return reply.status(401).send({ error: 'Invalid credentials' });
      
      // For now, this is a working example with mock validation
      // In production, validate against your user database
      if (!email || !password) {
        return reply.status(401).send({ error: 'Invalid credentials' });
      }
      
      const jwt = require('jsonwebtoken');
      const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
      const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';
      
      // Generate JWT token with user data
      // In production, fetch real user data from database
      const token = jwt.sign(
        { 
          userId: 'user-id-from-db', // Replace with actual user ID
          email: email,
          role: 'user' // Replace with actual user role
        },
        JWT_SECRET,
        { expiresIn: JWT_EXPIRES_IN }
      );
      
      // Set token in httpOnly cookie for security
      reply.setCookie('access_token', token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'strict',
        maxAge: 24 * 60 * 60 * 1000, // 24 hours
        path: '/'
      });
      
      return { 
        message: 'Logged in successfully',
        user: { email: email, role: 'user' },
        token: token // Also return in response for localStorage option
      };
    });

    fastify.post('/api/auth/logout', async (request, reply) => {
      // Clear authentication cookies
      reply.clearCookie('access_token');
      reply.clearCookie('refresh_token');
      return { message: 'Logged out successfully' };
    });

    // JWT authentication decorator
    fastify.decorate('authenticate', async function(request, reply) {
      const jwt = require('jsonwebtoken');
      const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-in-production';
      
      try {
        // Get token from cookie or Authorization header
        const token = request.cookies.access_token || 
                      (request.headers.authorization && request.headers.authorization.split(' ')[1]);
        
        if (!token) {
          return reply.status(401).send({ error: 'Authentication required' });
        }
        
        const decoded = jwt.verify(token, JWT_SECRET);
        request.user = decoded; // Attach user data to request
      } catch (error) {
        return reply.status(403).send({ error: 'Invalid or expired token' });
      }
    });

    fastify.get('/api/auth/profile', {
      onRequest: [fastify.authenticate]
    }, async (request, reply) => {
      // User data is available in request.user (set by authenticate decorator)
      return { 
        message: 'Profile data',
        user: {
          userId: request.user.userId,
          email: request.user.email,
          role: request.user.role
        }
      };
    });

    // bffgen:begin:routes
    // Auto-generated route imports and registrations
    // Do not modify this section manually - use 'bffgen generate' to update
{{.BackendRoutes}}
    // bffgen:end:routes

    // Error handler
    fastify.setErrorHandler((error, request, reply) => {
      const isDevelopment = process.env.NODE_ENV !== 'production';
      
      fastify.log.error(error);
      
      reply.status(error.statusCode || 500).send({
        error: isDevelopment ? error.message : 'Internal server error',
        ...(isDevelopment && { 
          code: error.code,
          stack: error.stack 
        })
      });
    });

    // 404 handler
    fastify.setNotFoundHandler((request, reply) => {
      reply.status(404).send({ 
        error: 'Route not found',
        path: request.url,
        method: request.method
      });
    });

    // Graceful shutdown
    const closeGracefully = async (signal) => {
      fastify.log.info(`Received signal ${signal}, closing gracefully`);
      await fastify.close();
      process.exit(0);
    };

    process.on('SIGTERM', () => closeGracefully('SIGTERM'));
    process.on('SIGINT', () => closeGracefully('SIGINT'));

    // Start server
    await fastify.listen({ 
      port: PORT, 
      host: process.env.HOST || '0.0.0.0' 
    });
    
    fastify.log.info(`ğŸš€ {{.ProjectName}} BFF server running on port ${PORT}`);
    fastify.log.info(`ğŸ“‹ Health check: http://localhost:${PORT}/health`);
    fastify.log.info(`ğŸŒ Environment: ${process.env.NODE_ENV || 'development'}`);

  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
}

start();

