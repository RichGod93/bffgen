/**
 * {{.ServiceName}} Controller (Aggregator)
 * Auto-generated by bffgen
 * 
 * Aggregator controller with data transformation and multi-service support
 */

const {{.ServiceName}}Service = require('../services/{{.ServiceName}}.service');
const ParallelAggregator = require('../utils/aggregator');
const CacheManager = require('../utils/cache-manager');
const CircuitBreaker = require('../utils/circuit-breaker');
const ResponseTransformer = require('../utils/response-transformer');

class {{.ServiceNamePascal}}Controller {
  constructor() {
    this.service = new {{.ServiceName}}Service();
    this.aggregator = new ParallelAggregator({ timeout: 5000 });
    this.cache = new CacheManager({ ttl: 300, prefix: '{{.ServiceName}}:' });
    this.circuitBreaker = new CircuitBreaker({ 
      failureThreshold: 5, 
      resetTimeout: 60000 
    });
  }

{{range .Endpoints}}
  /**
   * {{.Method}} {{.Path}}
   * {{if .RequiresAuth}}@requires Authentication{{else}}@public{{end}}
   */
  async {{.HandlerName}}(request, reply) {
    try {
      const cacheKey = this.buildCacheKey('{{.HandlerName}}', request.params, request.query);
      
      // Check cache first
      const cached = await this.cache.get(cacheKey);
      if (cached) {
        request.log.debug(`Cache hit for {{.HandlerName}}`);
        return cached;
      }

      request.log.info(`Processing {{.Method}} {{.Path}}`, {
        params: request.params,
        userId: request.user?.userId
      });

      // Execute with circuit breaker for resilience
      const result = await this.circuitBreaker.execute(
        () => this.service.{{.HandlerName}}(request.params, request.query, request.body, request.headers),
        () => this.getFallbackData('{{.HandlerName}}') // Fallback on circuit open
      );

      // Transform response for frontend
      const transformed = this.transformData(result);

      // Cache the transformed result
      await this.cache.set(cacheKey, transformed, 300);

      request.log.debug(`Successfully processed {{.Method}} {{.Path}}`);
      return transformed;
    } catch (error) {
      request.log.error(`Error in {{.HandlerName}}:`, error);
      throw error;
    }
  }
{{end}}

  /**
   * Example: Aggregate data from multiple services
   * Demonstrates parallel fetching with graceful degradation
   */
  async aggregateData(request, reply) {
    try {
      const userId = request.params.id;
      
      // Fetch from multiple services in parallel
      const results = await this.aggregator.fetchParallel([
        { 
          name: 'user', 
          fetch: () => this.service.getUser(userId) 
        },
        { 
          name: 'orders', 
          fetch: () => this.service.getOrders(userId) 
        },
        { 
          name: 'preferences', 
          fetch: () => this.service.getPreferences(userId) 
        }
      ]);

      // Combine successful results with graceful degradation
      const aggregated = {
        user: results.find(r => r.service === 'user' && r.success)?.data || null,
        orders: results.find(r => r.service === 'orders' && r.success)?.data || [],
        preferences: results.find(r => r.service === 'preferences' && r.success)?.data || {}
      };

      // Transform for frontend - only send what's needed
      const transformed = ResponseTransformer.merge(
        ResponseTransformer.pick(aggregated.user, ['id', 'name', 'email']),
        { orders: aggregated.orders, preferences: aggregated.preferences }
      );

      // Include partial failure information
      const failed = results.filter(r => !r.success);
      if (failed.length > 0) {
        transformed._warnings = failed.map(f => `${f.service}: ${f.error}`);
      }

      return transformed;
    } catch (error) {
      request.log.error('Aggregation error:', error);
      throw error;
    }
  }

  /**
   * Build cache key from method, params, and query
   */
  buildCacheKey(method, params, query) {
    return `${method}:${JSON.stringify(params)}:${JSON.stringify(query)}`;
  }

  /**
   * Transform data for endpoints
   * Override this method to customize transformations per endpoint
   */
  transformData(data) {
    // Remove sensitive fields
    return ResponseTransformer.sanitize(data);
  }

  /**
   * Get fallback data when service is unavailable
   */
  getFallbackData(method) {
    return { 
      error: 'Service temporarily unavailable', 
      data: null,
      fallback: true 
    };
  }

  /**
   * Get circuit breaker status (useful for health checks)
   */
  getCircuitStatus() {
    return this.circuitBreaker.getState();
  }
}

module.exports = new {{.ServiceNamePascal}}Controller();
