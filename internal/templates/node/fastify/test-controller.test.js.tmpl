/**
 * Controller Tests Template (Fastify)
 * Auto-generated by bffgen
 * 
 * Example controller tests for Fastify
 * Copy and modify for your specific controllers
 */

describe('Example Controller Tests (Fastify)', () => {
  let controller;
  let mockService;
  let mockRequest;
  let mockReply;

  beforeEach(() => {
    // Mock the service layer
    mockService = {
      getAll: jest.fn(),
      getById: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn()
    };

    // Mock Fastify request/reply
    mockRequest = {
      params: {},
      query: {},
      body: {},
      headers: {},
      user: null,
      log: {
        info: jest.fn(),
        error: jest.fn(),
        debug: jest.fn(),
        warn: jest.fn()
      }
    };

    mockReply = {
      code: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis(),
      header: jest.fn().mockReturnThis()
    };

    // Controller would be imported here
    // controller = require('../src/controllers/example.controller');
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('getAll', () => {
    it('should return all items successfully', async () => {
      const mockData = [{ id: '1', name: 'Item 1' }, { id: '2', name: 'Item 2' }];
      mockService.getAll.mockResolvedValue(mockData);

      // const result = await controller.getAll(mockRequest, mockReply);

      // expect(mockService.getAll).toHaveBeenCalledTimes(1);
      // expect(result).toEqual(mockData);
    });

    it('should handle service errors', async () => {
      const mockError = new Error('Service error');
      mockService.getAll.mockRejectedValue(mockError);

      // await expect(controller.getAll(mockRequest, mockReply)).rejects.toThrow('Service error');
      // expect(mockRequest.log.error).toHaveBeenCalled();
    });
  });

  describe('getById', () => {
    it('should return item by id successfully', async () => {
      mockRequest.params = { id: '1' };
      const mockData = { id: '1', name: 'Item 1' };
      mockService.getById.mockResolvedValue(mockData);

      // const result = await controller.getById(mockRequest, mockReply);

      // expect(mockService.getById).toHaveBeenCalledWith('1');
      // expect(result).toEqual(mockData);
    });

    it('should handle not found errors', async () => {
      mockRequest.params = { id: '999' };
      const mockError = new Error('Not found');
      mockError.status = 404;
      mockService.getById.mockRejectedValue(mockError);

      // await expect(controller.getById(mockRequest, mockReply)).rejects.toThrow('Not found');
    });
  });

  describe('create', () => {
    it('should create new item successfully', async () => {
      const newItem = { name: 'New Item' };
      mockRequest.body = newItem;
      const createdItem = { id: '3', ...newItem };
      mockService.create.mockResolvedValue(createdItem);

      // const result = await controller.create(mockRequest, mockReply);

      // expect(mockService.create).toHaveBeenCalledWith(newItem);
      // expect(result).toEqual(createdItem);
    });

    it('should handle validation errors', async () => {
      mockRequest.body = {};
      const mockError = new Error('Validation error');
      mockError.status = 400;
      mockService.create.mockRejectedValue(mockError);

      // await expect(controller.create(mockRequest, mockReply)).rejects.toThrow('Validation error');
    });
  });
});

