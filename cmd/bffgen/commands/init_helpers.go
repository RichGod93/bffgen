package commands

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/RichGod93/bffgen/internal/scaffolding"
	"github.com/RichGod93/bffgen/internal/templates"
)

// createProjectDirectories creates directories based on language type
func createProjectDirectories(projectName string, langType scaffolding.LanguageType) error {
	var dirs []string

	if langType == scaffolding.LanguageGo {
		// Go-specific directories
		dirs = []string{
			filepath.Join(projectName, "internal", "routes"),
			filepath.Join(projectName, "internal", "aggregators"),
			filepath.Join(projectName, "internal", "templates"),
			filepath.Join(projectName, "cmd", "server"),
		}
	} else {
		// Node.js-specific directories with src/ structure
		dirs = []string{
			filepath.Join(projectName, "src"),
			filepath.Join(projectName, "src", "routes"),
			filepath.Join(projectName, "src", "middleware"),
			filepath.Join(projectName, "src", "controllers"),
			filepath.Join(projectName, "src", "utils"),
			filepath.Join(projectName, "src", "config"),
			filepath.Join(projectName, "tests"),
			filepath.Join(projectName, "tests", "unit"),
			filepath.Join(projectName, "tests", "integration"),
		}
	}

	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return err
		}
	}

	return nil
}

// createDependencyFiles creates language-specific dependency files
func createDependencyFiles(projectName string, langType scaffolding.LanguageType, framework string) error {
	switch langType {
	case scaffolding.LanguageGo:
		return createGoModFile(projectName, framework)
	case scaffolding.LanguageNodeExpress, scaffolding.LanguageNodeFastify:
		return createPackageJsonFile(projectName, langType, framework)
	default:
		return nil
	}
}

// createGoModFile creates go.mod file for Go projects
func createGoModFile(projectName, framework string) error {
	content := generateGoModContent(projectName, framework)
	return os.WriteFile(filepath.Join(projectName, "go.mod"), []byte(content), 0644)
}

// createPackageJsonFile creates package.json file for Node.js projects
func createPackageJsonFile(projectName string, langType scaffolding.LanguageType, framework string) error {
	content := generatePackageJsonContent(projectName, langType, framework)
	return os.WriteFile(filepath.Join(projectName, "package.json"), []byte(content), 0644)
}

// createMainFile creates the main server file based on language/framework
func createMainFile(projectName string, langType scaffolding.LanguageType, framework string, corsConfig string, backendServs []BackendService) error {
	switch langType {
	case scaffolding.LanguageGo:
		return createGoMainFile(projectName, framework, corsConfig)
	case scaffolding.LanguageNodeExpress:
		return createNodeExpressMainFileFromTemplate(projectName, backendServs)
	case scaffolding.LanguageNodeFastify:
		return createNodeFastifyMainFileFromTemplate(projectName, backendServs)
	default:
		return nil
	}
}

// generateGoMod generates go.mod file content (legacy wrapper for tests)
func generateGoMod(projectName, framework string) string {
	return generateGoModContent(projectName, framework)
}

// generateGoModContent creates content for go.mod file
func generateGoModContent(projectName, framework string) string {
	baseContent := `module ` + projectName + `

go 1.21

require (
	gopkg.in/yaml.v3 v3.0.1
)`

	switch framework {
	case "chi":
		return `module ` + projectName + `

go 1.21

require (
	github.com/go-chi/chi/v5 v5.2.3
	github.com/go-chi/cors v1.2.2
	github.com/golang-jwt/jwt/v5 v5.3.0
	gopkg.in/yaml.v3 v3.0.1
)`
	case "echo":
		return `module ` + projectName + `

go 1.21

require (
	github.com/labstack/echo/v4 v4.11.4
	github.com/golang-jwt/jwt/v5 v5.3.0
	gopkg.in/yaml.v3 v3.0.1
)`
	case "fiber":
		return `module ` + projectName + `

go 1.21

require (
	github.com/gofiber/fiber/v2 v2.52.9
	github.com/golang-jwt/jwt/v5 v5.3.0
	gopkg.in/yaml.v3 v3.0.1
)`
	default:
		return baseContent
	}
}

// generatePackageJsonContent creates content for package.json file
func generatePackageJsonContent(projectName string, langType scaffolding.LanguageType, framework string) string {
	var dependencies string
	switch framework {
	case "express":
		dependencies = `{
  "name": "` + projectName + `",
  "version": "1.0.0",
  "description": "Backend-for-Frontend service generated by bffgen",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "test": "jest"
  },
  "keywords": ["bff", "backend-for-frontend", "api"],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "express-rate-limit": "^7.1.5",
    "jsonwebtoken": "^9.0.2",
    "cookie-parser": "^1.4.6",
    "express-validator": "^7.0.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.7.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}`
	case "fastify":
		dependencies = `{
  "name": "` + projectName + `",
  "version": "1.0.0",
  "description": "Backend-for-Frontend service generated by bffgen",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "test": "jest"
  },
  "keywords": ["bff", "backend-for-frontend", "api"],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@fastify/cors": "^8.5.0",
    "@fastify/helmet": "^11.1.1",
    "@fastify/rate-limit": "^9.1.0",
    "fastify": "^4.28.1",
    "@fastify/jwt": "^7.2.4",
    "@fastify/cookie": "^9.3.1"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.7.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}`
	default:
		dependencies = ""
	}
	return dependencies
}

// createGoMainFile creates Go main.go file
func createGoMainFile(projectName, framework, corsConfig string) error {
	// For now, just create a placeholder - this would need the full Go template logic
	content := `package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		fmt.Fprint(w, "BFF server is running!")
	})

	fmt.Println("ðŸš€ BFF server starting on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}
`
	return os.WriteFile(filepath.Join(projectName, "main.go"), []byte(content), 0644)
}

// createNodeExpressMainFile creates Express.js index.js file
func createNodeExpressMainFile(projectName string) error {
	content := `// Generated Express.js BFF server
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const cookieParser = require('cookie-parser');
const { body, validationResult } = require('express-validator');

const app = express();
const PORT = process.env.PORT || 8080;

// Middleware
app.use(helmet());
app.use(cookieParser());
app.use(express.json({ limit: '5mb' }));
app.use(express.urlencoded({ extended: true }));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.'
});
app.use(limiter);

// CORS configuration
app.use(cors({
  origin: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Accept', 'Authorization', 'Content-Type', 'X-CSRF-Token']
}));

// Security headers middleware
app.use((req, res, next) => {
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  next();
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'healthy', timestamp: new Date().toISOString() });
});

// Auth endpoints placeholder
app.post('/api/auth/login', (req, res) => {
  // TODO: Implement your authentication logic
  res.json({ message: 'Login endpoint - implement authentication' });
});

app.get('/api/auth/profile', (req, res) => {
  // TODO: Add JWT validation middleware
  res.json({ message: 'Profile endpoint - add authentication' });
});

// TODO: Add your BFF routes here
// Example:
// app.get('/api/users', async (req, res) => {
//   try {
//     const response = await fetch('http://your-backend/users');
//     const data = await response.json();
//     res.json(data);
//   } catch (error) {
//     res.status(500).json({ error: 'Failed to fetch users' });
//   }
// });

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: 'Something went wrong!' });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// Start server
app.listen(PORT, () => {
  console.log('ðŸš€ BFF server running on port ' + PORT);
  console.log('ðŸ“‹ Health check: http://localhost:' + PORT + '/health');
});

module.exports = app;
`
	return os.WriteFile(filepath.Join(projectName, "index.js"), []byte(content), 0644)
}

// createNodeFastifyMainFile creates Fastify index.js file  
func createNodeFastifyMainFile(projectName string) error {
	content := `// Generated Fastify BFF server
const fastify = require('fastify')({ 
  logger: {
    level: 'info',
    prettyPrint: process.env.NODE_ENV === 'development'
  }
});

const PORT = process.env.PORT || 8080;

// Register plugins
async function start() {
  // CORS configuration
  await fastify.register(require('@fastify/cors'), {
    origin: process.env.CORS_ORIGINS?.split(',') || ['http://localhost:3000'],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Accept', 'Authorization', 'Content-Type', 'X-CSRF-Token']
  });

  // Security headers
  await fastify.register(require('@fastify/helmet'), {
    contentSecurityPolicy: {
      directives: {
        defaultSrc: ["'self'"],
        styleSrc: ["'self'", "'unsafe-inline'"],
        scriptSrc: ["'self'"],
        imgSrc: ["'self'", "data:"],
        fontSrc: ["'self'"],
        connectSrc: ["'self'"],
        frameAncestors: ["'none'"]
      }
    }
  });

  // Rate limiting
  await fastify.register(require('@fastify/rate-limit'), {
    max: 100,
    timeWindow: '15 minutes'
  });

  // Cookie support
  await fastify.register(require('@fastify/cookie'));

  // Health check endpoint
  fastify.get('/health', async (request, reply) => {
    return { status: 'healthy', timestamp: new Date().toISOString() };
  });

  // Auth endpoints placeholder
  fastify.post('/api/auth/login', async (request, reply) => {
    // TODO: Implement your authentication logic
    return { message: 'Login endpoint - implement authentication' };
  });

  fastify.get('/api/auth/profile', async (request, reply) => {
    // TODO: Add JWT validation hook
    return { message: 'Profile endpoint - add authentication' };
  });

  // TODO: Add your BFF routes here
  // Example:
  // fastify.get('/api/users', async (request, reply) => {
  //   try {
  //     const response = await fetch('http://your-backend/users');
  //     const data = await response.json();
  //     return data;
  //   } catch (error) {
  //     reply.status(500);
  //     return { error: 'Failed to fetch users' };
  //   }
  // });

  // Error handler
  fastify.setErrorHandler((error, request, reply) => {
    fastify.log.error(error);
    reply.status(500).send({ error: 'Something went wrong!' });
  });

  // 404 handler
  fastify.setNotFoundHandler((request, reply) => {
    reply.status(404).send({ error: 'Route not found' });
  });

  // Start server
  try {
    await fastify.listen({ port: PORT, host: '0.0.0.0' });
    fastify.log.info('ðŸš€ BFF server running on port ' + PORT);
    fastify.log.info('ðŸ“‹ Health check: http://localhost:' + PORT + '/health');
  } catch (err) {
    fastify.log.error(err);
    process.exit(1);
  }
}

start();
`
	return os.WriteFile(filepath.Join(projectName, "index.js"), []byte(content), 0644)
}

// generateCORSConfig generates CORS config for Go frameworks (legacy wrapper for tests)
func generateCORSConfig(origins []string, framework string) string {
	return generateCORSConfigWithLang(origins, framework, scaffolding.LanguageGo)
}

// generateCORSConfigWithLang generates CORS config with language support
func generateCORSConfigWithLang(origins []string, framework string, langType scaffolding.LanguageType) string {
	// For Node.js, return empty for now (it will be in the template)
	if langType != scaffolding.LanguageGo {
		return ""
	}
	
	originsStr := ""
	for i, origin := range origins {
		if i > 0 {
			originsStr += ", "
		}
		originsStr += `"` + origin + `"`
	}

	switch framework {
	case "chi":
		return `r.Use(cors.Handler(cors.Options{
		AllowedOrigins:   []string{` + originsStr + `},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposedHeaders:   []string{"Link"},
		AllowCredentials: true,
		MaxAge:           300,
	}))`
	case "echo":
		return `e.Use(middleware.CORSWithConfig(middleware.CORSConfig{
		AllowOrigins:     []string{` + originsStr + `},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowHeaders:     []string{"Accept", "Authorization", "Content-Type", "X-CSRF-Token"},
		ExposeHeaders:    []string{"Link"},
		AllowCredentials: true,
		MaxAge:           300,
	}))`
	case "fiber":
		originsStr = ""
		for i, origin := range origins {
			if i > 0 {
				originsStr += ","
			}
			originsStr += origin
		}
		return `app.Use(cors.New(cors.Config{
		AllowOrigins:     "` + originsStr + `",
		AllowMethods:     "GET,POST,PUT,DELETE,OPTIONS",
		AllowHeaders:     "Accept,Authorization,Content-Type,X-CSRF-Token",
		ExposeHeaders:    "Link",
		AllowCredentials: true,
		MaxAge:           300,
	}))`
	default:
		return ""
	}
}

// createNodeExpressMainFileFromTemplate creates Express index.js from template
func createNodeExpressMainFileFromTemplate(projectName string, backendServs []BackendService) error {
	loader := templates.NewTemplateLoader(scaffolding.LanguageNodeExpress)
	
	// Convert backend services to template format
	var services []templates.BackendServiceData
	for _, svc := range backendServs {
		services = append(services, templates.BackendServiceData{
			Name:    svc.Name,
			BaseURL: svc.BaseURL,
			Port:    svc.Port,
		})
	}
	
	// Prepare template data
	data := &templates.TemplateData{
		ProjectName:        projectName,
		Runtime:            "nodejs-express",
		Framework:          "express",
		CORSOrigins:        templates.FormatCORSOriginsForJS([]string{"localhost:3000", "localhost:3001"}),
		CORSOriginsEnv:     templates.FormatCORSOriginsForEnv([]string{"localhost:3000", "localhost:3001"}),
		BackendRoutes:      templates.GenerateExpressRoutes(services),
		BackendServicesEnv: templates.GenerateBackendServicesEnv(services),
		BackendsJSON:       templates.GenerateBackendsJSON(services),
		BackendServices:    services,
	}
	
	// Render templates
	indexContent, err := loader.RenderTemplate("express", "index.js.tmpl", data)
	if err != nil {
		return err
	}
	
	packageContent, err := loader.RenderTemplate("express", "package.json.tmpl", data)
	if err != nil {
		return err
	}
	
	envContent, err := loader.RenderTemplate("express", "env.tmpl", data)
	if err != nil {
		return err
	}
	
	gitignoreContent, err := loader.RenderTemplate("express", "gitignore.tmpl", data)
	if err != nil {
		return err
	}
	
	bffgenConfigContent, err := loader.RenderTemplate("express", "bffgen.config.json.tmpl", data)
	if err != nil {
		return err
	}
	
	// Write files to src/
	if err := os.WriteFile(filepath.Join(projectName, "src", "index.js"), []byte(indexContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(projectName, "package.json"), []byte(packageContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(projectName, ".env.example"), []byte(envContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(projectName, ".gitignore"), []byte(gitignoreContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(projectName, "bffgen.config.json"), []byte(bffgenConfigContent), 0644); err != nil {
		return err
	}
	
	// Generate middleware files
	if err := createExpressMiddleware(projectName, loader); err != nil {
		return err
	}
	
	return nil
}

// createNodeFastifyMainFileFromTemplate creates Fastify index.js from template
func createNodeFastifyMainFileFromTemplate(projectName string, backendServs []BackendService) error {
	loader := templates.NewTemplateLoader(scaffolding.LanguageNodeFastify)
	
	// Convert backend services to template format
	var services []templates.BackendServiceData
	for _, svc := range backendServs {
		services = append(services, templates.BackendServiceData{
			Name:    svc.Name,
			BaseURL: svc.BaseURL,
			Port:    svc.Port,
		})
	}
	
	// Prepare template data
	data := &templates.TemplateData{
		ProjectName:        projectName,
		Runtime:            "nodejs-fastify",
		Framework:          "fastify",
		CORSOrigins:        templates.FormatCORSOriginsForJS([]string{"localhost:3000", "localhost:3001"}),
		CORSOriginsEnv:     templates.FormatCORSOriginsForEnv([]string{"localhost:3000", "localhost:3001"}),
		BackendRoutes:      templates.GenerateFastifyRoutes(services),
		BackendServicesEnv: templates.GenerateBackendServicesEnv(services),
		BackendsJSON:       templates.GenerateBackendsJSON(services),
		BackendServices:    services,
	}
	
	// Render templates
	indexContent, err := loader.RenderTemplate("fastify", "index.js.tmpl", data)
	if err != nil {
		return err
	}
	
	packageContent, err := loader.RenderTemplate("fastify", "package.json.tmpl", data)
	if err != nil {
		return err
	}
	
	envContent, err := loader.RenderTemplate("fastify", "env.tmpl", data)
	if err != nil {
		return err
	}
	
	gitignoreContent, err := loader.RenderTemplate("fastify", "gitignore.tmpl", data)
	if err != nil {
		return err
	}
	
	bffgenConfigContent, err := loader.RenderTemplate("fastify", "bffgen.config.json.tmpl", data)
	if err != nil {
		return err
	}
	
	// Write files to src/
	if err := os.WriteFile(filepath.Join(projectName, "src", "index.js"), []byte(indexContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(projectName, "package.json"), []byte(packageContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(projectName, ".env.example"), []byte(envContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(projectName, ".gitignore"), []byte(gitignoreContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(projectName, "bffgen.config.json"), []byte(bffgenConfigContent), 0644); err != nil {
		return err
	}
	
	// Generate middleware files
	if err := createFastifyMiddleware(projectName, loader); err != nil {
		return err
	}
	
	return nil
}

// createExpressMiddleware creates middleware files for Express
func createExpressMiddleware(projectName string, loader *templates.TemplateLoader) error {
	// Create middleware directory
	middlewareDir := filepath.Join(projectName, "src", "middleware")
	
	// Render middleware templates
	authContent, err := loader.RenderTemplate("express", "middleware-auth.js.tmpl", &templates.TemplateData{})
	if err != nil {
		return fmt.Errorf("failed to render auth middleware: %w", err)
	}
	
	errorContent, err := loader.RenderTemplate("express", "middleware-error.js.tmpl", &templates.TemplateData{})
	if err != nil {
		return fmt.Errorf("failed to render error middleware: %w", err)
	}
	
	// Write middleware files
	if err := os.WriteFile(filepath.Join(middlewareDir, "auth.js"), []byte(authContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(middlewareDir, "errorHandler.js"), []byte(errorContent), 0644); err != nil {
		return err
	}
	
	return nil
}

// createFastifyMiddleware creates middleware files for Fastify
func createFastifyMiddleware(projectName string, loader *templates.TemplateLoader) error {
	// Create middleware directory
	middlewareDir := filepath.Join(projectName, "src", "middleware")
	
	// Render middleware templates
	authContent, err := loader.RenderTemplate("fastify", "middleware-auth.js.tmpl", &templates.TemplateData{})
	if err != nil {
		return fmt.Errorf("failed to render auth middleware: %w", err)
	}
	
	errorContent, err := loader.RenderTemplate("fastify", "middleware-error.js.tmpl", &templates.TemplateData{})
	if err != nil {
		return fmt.Errorf("failed to render error middleware: %w", err)
	}
	
	// Write middleware files
	if err := os.WriteFile(filepath.Join(middlewareDir, "auth.js"), []byte(authContent), 0644); err != nil {
		return err
	}
	
	if err := os.WriteFile(filepath.Join(middlewareDir, "errorHandler.js"), []byte(errorContent), 0644); err != nil {
		return err
	}
	
	return nil
}

