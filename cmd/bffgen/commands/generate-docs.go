package commands

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/RichGod93/bffgen/internal/utils"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

var generateDocsCmd = &cobra.Command{
	Use:   "generate-docs",
	Short: "Generate OpenAPI documentation from config",
	Long:  `Generate OpenAPI 3.0 specification from bffgen.config.json`,
	Run: func(cmd *cobra.Command, args []string) {
		if err := generateDocs(); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating docs: %v\n", err)
			os.Exit(1)
		}
	},
}

var (
	outputFormat string
	outputPath   string
)

func init() {
	generateDocsCmd.Flags().StringVarP(&outputFormat, "format", "f", "yaml", "Output format (yaml or json)")
	generateDocsCmd.Flags().StringVarP(&outputPath, "output", "o", "docs/openapi.yaml", "Output file path")
}

func generateDocs() error {
	fmt.Println("üìö Generating OpenAPI documentation from bffgen.config.json")

	// Check if config file exists
	if _, err := os.Stat("bffgen.config.json"); os.IsNotExist(err) {
		fmt.Println("‚ùå bffgen.config.json not found in current directory")
		fmt.Println("üí° Run 'bffgen init <project-name>' first or navigate to a BFF project directory")
		return fmt.Errorf("config file not found")
	}

	// Load bffgen.config.json
	configData, err := os.ReadFile("bffgen.config.json")
	if err != nil {
		return fmt.Errorf("failed to read config: %w", err)
	}

	var config map[string]interface{}
	if err := json.Unmarshal(configData, &config); err != nil {
		return fmt.Errorf("failed to parse config: %w", err)
	}

	// Extract project info
	projectInfo, _ := config["project"].(map[string]interface{})
	projectName, _ := projectInfo["name"].(string)
	if projectName == "" {
		projectName = "BFF API"
	}

	// Extract backends
	backends, ok := config["backends"].([]interface{})
	if !ok || len(backends) == 0 {
		fmt.Println("‚ö†Ô∏è  No backends configured in bffgen.config.json")
		return nil
	}

	// Generate OpenAPI spec
	openAPISpec := generateOpenAPISpec(projectName, backends)

	// Create docs directory if it doesn't exist
	docsDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(docsDir, utils.ProjectDirPerm); err != nil {
		return fmt.Errorf("failed to create docs directory: %w", err)
	}

	// Write output based on format
	var outputData []byte
	if outputFormat == "json" {
		outputData, err = json.MarshalIndent(openAPISpec, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal JSON: %w", err)
		}
	} else {
		outputData, err = yaml.Marshal(openAPISpec)
		if err != nil {
			return fmt.Errorf("failed to marshal YAML: %w", err)
		}
	}

	if err := os.WriteFile(outputPath, outputData, utils.ProjectFilePerm); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	fmt.Println()
	fmt.Printf("‚úÖ OpenAPI documentation generated successfully!\n")
	fmt.Printf("üìÅ Output file: %s\n", outputPath)
	fmt.Println()
	fmt.Println("üí° You can now:")
	fmt.Println("   1. View it in Swagger UI: http://localhost:8080/api-docs")
	fmt.Println("   2. Import it into Postman")
	fmt.Println("   3. Use it for API client generation")

	return nil
}

func generateOpenAPISpec(projectName string, backends []interface{}) map[string]interface{} {
	spec := map[string]interface{}{
		"openapi": "3.0.0",
		"info": map[string]interface{}{
			"title":       projectName + " API",
			"version":     "1.0.0",
			"description": "Backend-for-Frontend API generated by bffgen",
			"contact": map[string]interface{}{
				"name": "API Support",
			},
			"license": map[string]interface{}{
				"name": "MIT",
			},
		},
		"servers": []map[string]interface{}{
			{
				"url":         "http://localhost:8080",
				"description": "Development server",
			},
		},
		"tags":       generateTags(backends),
		"paths":      generatePaths(backends),
		"components": generateComponents(),
	}

	return spec
}

func generateTags(backends []interface{}) []map[string]interface{} {
	tags := []map[string]interface{}{
		{
			"name":        "health",
			"description": "Health check endpoints",
		},
		{
			"name":        "auth",
			"description": "Authentication endpoints",
		},
	}

	for _, backend := range backends {
		backendMap, ok := backend.(map[string]interface{})
		if !ok {
			continue
		}

		serviceName, _ := backendMap["name"].(string)
		if serviceName != "" {
			tags = append(tags, map[string]interface{}{
				"name":        serviceName,
				"description": fmt.Sprintf("%s service endpoints", strings.Title(serviceName)),
			})
		}
	}

	return tags
}

func generatePaths(backends []interface{}) map[string]interface{} {
	paths := map[string]interface{}{
		"/health": map[string]interface{}{
			"get": map[string]interface{}{
				"tags":        []string{"health"},
				"summary":     "Health check",
				"description": "Check if the BFF service is running",
				"responses": map[string]interface{}{
					"200": map[string]interface{}{
						"description": "Service is healthy",
						"content": map[string]interface{}{
							"application/json": map[string]interface{}{
								"schema": map[string]interface{}{
									"$ref": "#/components/schemas/HealthResponse",
								},
							},
						},
					},
				},
			},
		},
	}

	for _, backend := range backends {
		backendMap, ok := backend.(map[string]interface{})
		if !ok {
			continue
		}

		serviceName, _ := backendMap["name"].(string)
		endpoints, ok := backendMap["endpoints"].([]interface{})
		if !ok || len(endpoints) == 0 {
			continue
		}

		for _, ep := range endpoints {
			endpoint, ok := ep.(map[string]interface{})
			if !ok {
				continue
			}

			path, _ := endpoint["exposeAs"].(string)
			method, _ := endpoint["method"].(string)
			requiresAuth, _ := endpoint["requiresAuth"].(bool)

			if path == "" || method == "" {
				continue
			}

			// Initialize path if it doesn't exist
			if paths[path] == nil {
				paths[path] = make(map[string]interface{})
			}

			pathItem := paths[path].(map[string]interface{})

			// Create operation
			operation := map[string]interface{}{
				"tags":        []string{serviceName},
				"summary":     fmt.Sprintf("%s %s", method, path),
				"description": fmt.Sprintf("Proxies to %s service", serviceName),
				"responses": map[string]interface{}{
					"200": map[string]interface{}{
						"description": "Successful response",
						"content": map[string]interface{}{
							"application/json": map[string]interface{}{
								"schema": map[string]interface{}{
									"type": "object",
								},
							},
						},
					},
					"400": map[string]interface{}{
						"$ref": "#/components/responses/BadRequest",
					},
					"500": map[string]interface{}{
						"$ref": "#/components/responses/InternalServerError",
					},
				},
			}

			if requiresAuth {
				operation["security"] = []map[string]interface{}{
					{"bearerAuth": []string{}},
				}
				operation["responses"].(map[string]interface{})["401"] = map[string]interface{}{
					"$ref": "#/components/responses/Unauthorized",
				}
			}

			pathItem[strings.ToLower(method)] = operation
		}
	}

	return paths
}

func generateComponents() map[string]interface{} {
	return map[string]interface{}{
		"securitySchemes": map[string]interface{}{
			"bearerAuth": map[string]interface{}{
				"type":         "http",
				"scheme":       "bearer",
				"bearerFormat": "JWT",
				"description":  "JWT Bearer token authentication",
			},
		},
		"schemas": map[string]interface{}{
			"Error": map[string]interface{}{
				"type": "object",
				"properties": map[string]interface{}{
					"error": map[string]interface{}{
						"type":        "string",
						"description": "Error type",
					},
					"message": map[string]interface{}{
						"type":        "string",
						"description": "Error message",
					},
					"statusCode": map[string]interface{}{
						"type":        "integer",
						"description": "HTTP status code",
					},
				},
			},
			"HealthResponse": map[string]interface{}{
				"type": "object",
				"properties": map[string]interface{}{
					"status": map[string]interface{}{
						"type":        "string",
						"enum":        []string{"healthy", "unhealthy"},
						"description": "Health status",
					},
					"timestamp": map[string]interface{}{
						"type":        "string",
						"format":      "date-time",
						"description": "Current timestamp",
					},
					"uptime": map[string]interface{}{
						"type":        "number",
						"description": "Server uptime in seconds",
					},
					"environment": map[string]interface{}{
						"type":        "string",
						"enum":        []string{"development", "test", "production"},
						"description": "Current environment",
					},
				},
			},
		},
		"responses": map[string]interface{}{
			"BadRequest": map[string]interface{}{
				"description": "Bad request - validation error",
				"content": map[string]interface{}{
					"application/json": map[string]interface{}{
						"schema": map[string]interface{}{
							"$ref": "#/components/schemas/Error",
						},
					},
				},
			},
			"Unauthorized": map[string]interface{}{
				"description": "Unauthorized - authentication required",
				"content": map[string]interface{}{
					"application/json": map[string]interface{}{
						"schema": map[string]interface{}{
							"$ref": "#/components/schemas/Error",
						},
					},
				},
			},
			"InternalServerError": map[string]interface{}{
				"description": "Internal server error",
				"content": map[string]interface{}{
					"application/json": map[string]interface{}{
						"schema": map[string]interface{}{
							"$ref": "#/components/schemas/Error",
						},
					},
				},
			},
		},
	}
}
