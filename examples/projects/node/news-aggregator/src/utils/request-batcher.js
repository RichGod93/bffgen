/**
 * Request Batcher Utility
 * Auto-generated by bffgen
 * 
 * Batches multiple requests to prevent N+1 query problems
 */

class RequestBatcher {
  constructor(options = {}) {
    this.batchWindow = options.batchWindow || 10; // ms
    this.maxBatchSize = options.maxBatchSize || 50;
    this.batches = new Map(); // key -> { requests: [], timer: timeoutId }
  }

  /**
   * Batch a request
   * @param {string} key - Batch key
   * @param {Function} requestFn - Function that handles batched request
   * @param {any} itemId - Item identifier
   * @returns {Promise<any>}
   */
  async batch(key, requestFn, itemId) {
    return new Promise((resolve, reject) => {
      if (!this.batches.has(key)) {
        this.batches.set(key, { requests: [], timer: null });
      }

      const batch = this.batches.get(key);
      batch.requests.push({ itemId, resolve, reject });

      // Execute immediately if batch size reached
      if (batch.requests.length >= this.maxBatchSize) {
        clearTimeout(batch.timer);
        this.executeBatch(key, requestFn);
      } else if (!batch.timer) {
        // Schedule batch execution
        batch.timer = setTimeout(() => {
          this.executeBatch(key, requestFn);
        }, this.batchWindow);
      }
    });
  }

  /**
   * Execute a batch of requests
   * @param {string} key - Batch key
   * @param {Function} requestFn - Function that handles batched request
   */
  async executeBatch(key, requestFn) {
    const batch = this.batches.get(key);
    if (!batch || batch.requests.length === 0) return;

    this.batches.delete(key);
    const { requests } = batch;
    const itemIds = requests.map(r => r.itemId);

    try {
      const results = await requestFn(itemIds);
      
      // Create lookup map for results
      const resultsMap = new Map(
        Array.isArray(results) ? results.map(item => [item.id, item]) : []
      );

      // Resolve individual promises
      requests.forEach(({ itemId, resolve, reject }) => {
        const result = resultsMap.get(itemId);
        if (result) {
          resolve(result);
        } else {
          reject(new Error(`No result for item ${itemId}`));
        }
      });
    } catch (error) {
      // Reject all requests on batch failure
      requests.forEach(({ reject }) => reject(error));
    }
  }

  /**
   * Clear a specific batch
   * @param {string} key - Batch key
   */
  clear(key) {
    const batch = this.batches.get(key);
    if (batch) {
      clearTimeout(batch.timer);
      this.batches.delete(key);
    }
  }

  /**
   * Clear all batches
   */
  clearAll() {
    this.batches.forEach((batch, key) => {
      clearTimeout(batch.timer);
    });
    this.batches.clear();
  }

  /**
   * Get current batch statistics
   * @returns {Object}
   */
  getStats() {
    const stats = {
      activeBatches: this.batches.size,
      totalPendingRequests: 0,
      batches: []
    };

    this.batches.forEach((batch, key) => {
      stats.totalPendingRequests += batch.requests.length;
      stats.batches.push({
        key,
        pending: batch.requests.length
      });
    });

    return stats;
  }
}

module.exports = RequestBatcher;

