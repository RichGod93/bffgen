/**
 * Field Selector Utility
 * Auto-generated by bffgen
 * 
 * GraphQL-like field selection for REST endpoints
 * Allows clients to specify which fields they want: ?fields=id,name,email
 */

const ResponseTransformer = require('./response-transformer');

class FieldSelector {
  /**
   * Select fields from data based on query parameter
   * @param {Object|Array} data - Data to filter
   * @param {string} fieldsParam - Comma-separated field names
   * @param {Object} options - Additional options
   * @returns {Object|Array}
   */
  static selectFields(data, fieldsParam, options = {}) {
    if (!fieldsParam) return data;

    const fields = fieldsParam.split(',').map(f => f.trim());
    
    if (Array.isArray(data)) {
      return data.map(item => this.selectFromObject(item, fields, options));
    }
    
    return this.selectFromObject(data, fields, options);
  }

  /**
   * Select fields from a single object
   * @param {Object} obj - Object to filter
   * @param {Array<string>} fields - Fields to include
   * @param {Object} options - Options
   * @returns {Object}
   */
  static selectFromObject(obj, fields, options = {}) {
    if (!obj) return obj;

    const result = {};
    const { includeNested = true, defaultFields = [] } = options;

    // Combine requested fields with default fields
    const allFields = [...new Set([...fields, ...defaultFields])];

    allFields.forEach(field => {
      if (includeNested && field.includes('.')) {
        // Handle nested fields like "user.name"
        this.selectNestedField(obj, field, result);
      } else if (obj.hasOwnProperty(field)) {
        result[field] = obj[field];
      }
    });

    return result;
  }

  /**
   * Select nested field from object
   * @param {Object} obj - Source object
   * @param {string} path - Dot-notation path
   * @param {Object} result - Result object
   */
  static selectNestedField(obj, path, result) {
    const parts = path.split('.');
    let current = obj;
    let resultCurrent = result;

    for (let i = 0; i < parts.length - 1; i++) {
      const part = parts[i];
      if (!current[part]) return;
      
      if (!resultCurrent[part]) {
        resultCurrent[part] = {};
      }
      
      current = current[part];
      resultCurrent = resultCurrent[part];
    }

    const lastPart = parts[parts.length - 1];
    if (current.hasOwnProperty(lastPart)) {
      resultCurrent[lastPart] = current[lastPart];
    }
  }

  /**
   * Express middleware for field selection
   * Usage: router.get('/users', FieldSelector.middleware(), handler)
   */
  static middleware(options = {}) {
    const { 
      paramName = 'fields',
      defaultFields = [],
      includeNested = true 
    } = options;

    return (req, res, next) => {
      const originalJson = res.json.bind(res);
      
      res.json = function(data) {
        const fieldsParam = req.query[paramName];
        
        if (fieldsParam && data) {
          const filtered = FieldSelector.selectFields(data, fieldsParam, {
            defaultFields,
            includeNested
          });
          return originalJson(filtered);
        }
        
        return originalJson(data);
      };
      
      next();
    };
  }

  /**
   * Fastify decorator for field selection
   * Usage: reply.selectFields(data, request.query.fields)
   */
  static fastifyDecorator() {
    return function(fastify, opts, done) {
      fastify.decorateReply('selectFields', function(data, fieldsParam, options = {}) {
        if (!fieldsParam) {
          return this.send(data);
        }
        
        const filtered = FieldSelector.selectFields(data, fieldsParam, options);
        return this.send(filtered);
      });
      
      done();
    };
  }

  /**
   * Parse field selection with relationships
   * Example: "id,name,orders(id,total,status)"
   */
  static parseWithRelationships(fieldsParam) {
    const result = {
      fields: [],
      relationships: {}
    };

    const pattern = /(\w+)(?:\(([^)]+)\))?/g;
    let match;

    while ((match = pattern.exec(fieldsParam)) !== null) {
      const fieldName = match[1];
      const relationFields = match[2];

      if (relationFields) {
        result.relationships[fieldName] = relationFields.split(',').map(f => f.trim());
      } else {
        result.fields.push(fieldName);
      }
    }

    return result;
  }
}

module.exports = FieldSelector;

