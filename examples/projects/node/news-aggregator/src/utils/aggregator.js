/**
 * Parallel Aggregator Utility
 * Auto-generated by bffgen
 * 
 * Handles parallel service calls with timeout and error handling
 */

const logger = require('./logger');

class ParallelAggregator {
  constructor(options = {}) {
    this.timeout = options.timeout || 30000;
    this.failFast = options.failFast || false;
  }

  /**
   * Execute multiple service calls in parallel
   * @param {Array<{name: string, fetch: Function}>} serviceCalls - Array of service call definitions
   * @returns {Promise<Array<{service: string, data: any, error: string|null, success: boolean}>>}
   */
  async fetchParallel(serviceCalls) {
    const promises = serviceCalls.map(async (call) => {
      try {
        const result = await Promise.race([
          call.fetch(),
          this.timeoutPromise(this.timeout)
        ]);
        return { service: call.name, data: result, error: null, success: true };
      } catch (error) {
        logger.warn(`Service ${call.name} failed:`, error.message);
        return { service: call.name, data: null, error: error.message, success: false };
      }
    });

    if (this.failFast) {
      return await Promise.all(promises);
    } else {
      return await Promise.allSettled(promises).then(results =>
        results.map((r, i) => r.status === 'fulfilled' ? r.value : {
          service: serviceCalls[i].name,
          data: null,
          error: r.reason?.message || 'Unknown error',
          success: false
        })
      );
    }
  }

  /**
   * Execute service calls in waterfall (sequential with dependency)
   * @param {Array<{name: string, fetch: Function}>} serviceCalls - Array of service call definitions
   * @returns {Promise<Array>}
   */
  async fetchWaterfall(serviceCalls) {
    const results = [];
    for (const call of serviceCalls) {
      try {
        const result = await call.fetch(results);
        results.push({ service: call.name, data: result, error: null, success: true });
      } catch (error) {
        logger.error(`Waterfall execution failed at ${call.name}:`, error);
        results.push({ service: call.name, data: null, error: error.message, success: false });
        break; // Stop waterfall on first failure
      }
    }
    return results;
  }

  /**
   * Create a timeout promise that rejects after specified milliseconds
   * @param {number} ms - Timeout in milliseconds
   * @returns {Promise}
   */
  timeoutPromise(ms) {
    return new Promise((_, reject) =>
      setTimeout(() => reject(new Error(`Timeout after ${ms}ms`)), ms)
    );
  }
}

module.exports = ParallelAggregator;

