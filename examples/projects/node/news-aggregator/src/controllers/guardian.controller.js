/**
 * guardian Controller (Aggregator)
 * Auto-generated by bffgen
 * 
 * Aggregator controller with data transformation and multi-service support
 */

const guardianService = require('../services/guardian.service');
const ParallelAggregator = require('../utils/aggregator');
const CacheManager = require('../utils/cache-manager');
const CircuitBreaker = require('../utils/circuit-breaker');
const ResponseTransformer = require('../utils/response-transformer');
const logger = require('../utils/logger');

class GuardianController {
  constructor() {
    this.service = new guardianService();
    this.aggregator = new ParallelAggregator({ timeout: 5000 });
    this.cache = new CacheManager({ ttl: 300, prefix: 'guardian:' });
    this.circuitBreaker = new CircuitBreaker({ 
      failureThreshold: 5, 
      resetTimeout: 60000 
    });
  }


  /**
   * GET /api/news/guardian/headlines
   * @public
   */
  async getApiNewsGuardianHeadlines(req, res, next) {
    try {
      const cacheKey = this.buildCacheKey('getApiNewsGuardianHeadlines', req.params, req.query);
      
      // Check cache first
      const cached = await this.cache.get(cacheKey);
      if (cached) {
        logger.debug(`Cache hit for getApiNewsGuardianHeadlines`);
        return res.json(cached);
      }

      logger.info(`Processing GET /api/news/guardian/headlines`, {
        params: req.params,
        userId: req.userId
      });

      // Execute with circuit breaker for resilience
      const result = await this.circuitBreaker.execute(
        () => this.service.getApiNewsGuardianHeadlines(req.params, req.query, req.body, req.headers),
        () => this.getFallbackData('getApiNewsGuardianHeadlines') // Fallback on circuit open
      );

      // Transform response for frontend
      const transformed = this.transformData(result);

      // Cache the transformed result
      await this.cache.set(cacheKey, transformed, 300);

      logger.debug(`Successfully processed GET /api/news/guardian/headlines`);
      res.json(transformed);
    } catch (error) {
      logger.error(`Error in getApiNewsGuardianHeadlines:`, error);
      next(error);
    }
  }

  /**
   * GET /api/news/guardian/search
   * @public
   */
  async getApiNewsGuardianSearch(req, res, next) {
    try {
      const cacheKey = this.buildCacheKey('getApiNewsGuardianSearch', req.params, req.query);
      
      // Check cache first
      const cached = await this.cache.get(cacheKey);
      if (cached) {
        logger.debug(`Cache hit for getApiNewsGuardianSearch`);
        return res.json(cached);
      }

      logger.info(`Processing GET /api/news/guardian/search`, {
        params: req.params,
        userId: req.userId
      });

      // Execute with circuit breaker for resilience
      const result = await this.circuitBreaker.execute(
        () => this.service.getApiNewsGuardianSearch(req.params, req.query, req.body, req.headers),
        () => this.getFallbackData('getApiNewsGuardianSearch') // Fallback on circuit open
      );

      // Transform response for frontend
      const transformed = this.transformData(result);

      // Cache the transformed result
      await this.cache.set(cacheKey, transformed, 300);

      logger.debug(`Successfully processed GET /api/news/guardian/search`);
      res.json(transformed);
    } catch (error) {
      logger.error(`Error in getApiNewsGuardianSearch:`, error);
      next(error);
    }
  }


  /**
   * Example: Aggregate data from multiple services
   * Demonstrates parallel fetching with graceful degradation
   */
  async aggregateData(req, res, next) {
    try {
      const userId = req.params.id;
      
      // Fetch from multiple services in parallel
      const results = await this.aggregator.fetchParallel([
        { 
          name: 'user', 
          fetch: () => this.service.getUser(userId) 
        },
        { 
          name: 'orders', 
          fetch: () => this.service.getOrders(userId) 
        },
        { 
          name: 'preferences', 
          fetch: () => this.service.getPreferences(userId) 
        }
      ]);

      // Combine successful results with graceful degradation
      const aggregated = {
        user: results.find(r => r.service === 'user' && r.success)?.data || null,
        orders: results.find(r => r.service === 'orders' && r.success)?.data || [],
        preferences: results.find(r => r.service === 'preferences' && r.success)?.data || {}
      };

      // Transform for frontend - only send what's needed
      const transformed = ResponseTransformer.merge(
        ResponseTransformer.pick(aggregated.user, ['id', 'name', 'email']),
        { orders: aggregated.orders, preferences: aggregated.preferences }
      );

      // Include partial failure information
      const failed = results.filter(r => !r.success);
      if (failed.length > 0) {
        transformed._warnings = failed.map(f => `${f.service}: ${f.error}`);
      }

      res.json(transformed);
    } catch (error) {
      logger.error('Aggregation error:', error);
      next(error);
    }
  }

  /**
   * Build cache key from method, params, and query
   */
  buildCacheKey(method, params, query) {
    return `${method}:${JSON.stringify(params)}:${JSON.stringify(query)}`;
  }

  /**
   * Transform data for endpoints
   * Override this method to customize transformations per endpoint
   */
  transformData(data) {
    // Remove sensitive fields
    return ResponseTransformer.sanitize(data);
  }

  /**
   * Get fallback data when service is unavailable
   */
  getFallbackData(method) {
    logger.warn(`Using fallback data for ${method}`);
    return { 
      error: 'Service temporarily unavailable', 
      data: null,
      fallback: true 
    };
  }

  /**
   * Get circuit breaker status (useful for health checks)
   */
  getCircuitStatus() {
    return this.circuitBreaker.getState();
  }
}

module.exports = new GuardianController();
