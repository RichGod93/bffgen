/**
 * E-commerce Catalog Aggregator Example
 * Auto-generated by bffgen
 * 
 * Demonstrates advanced aggregation patterns:
 * - Parallel service calls
 * - Request batching to avoid N+1
 * - Circuit breaker for fallback
 * - Response caching
 */

const ParallelAggregator = require('../utils/aggregator');
const CacheManager = require('../utils/cache-manager');
const CircuitBreaker = require('../utils/circuit-breaker');
const ResponseTransformer = require('../utils/response-transformer');
const RequestBatcher = require('../utils/request-batcher');
const logger = require('../utils/logger');

// Example services (replace with your actual services)
// const ProductsService = require('../services/products.service');
// const InventoryService = require('../services/inventory.service');
// const ReviewsService = require('../services/reviews.service');

class EcommerceCatalogController {
  constructor() {
    this.aggregator = new ParallelAggregator({ timeout: 3000 });
    this.cache = new CacheManager({ ttl: 300, prefix: 'catalog:' });
    this.batcher = new RequestBatcher({ batchWindow: 10, maxBatchSize: 50 });
    this.inventoryBreaker = new CircuitBreaker({ failureThreshold: 5 });
  }

  /**
   * GET /api/catalog
   * Get product catalog with inventory and ratings
   */
  async getCatalog(req, res, next) {
    try {
      const { category, page = 1, limit = 20 } = req.query;
      const cacheKey = `catalog:${category}:${page}:${limit}`;

      // Check cache
      const cached = await this.cache.get(cacheKey);
      if (cached) {
        logger.info(`Catalog cache hit for category ${category}`);
        return res.json(cached);
      }

      logger.info(`Fetching catalog for category ${category}`);

      // Fetch products and inventory in parallel
      const results = await this.aggregator.fetchParallel([
        {
          name: 'products',
          fetch: async () => {
            // Replace with actual service call
            // return await ProductsService.getByCategory(category, { page, limit }, req.headers);
            
            // Mock data for example
            return {
              items: [
                { id: 'prod-1', name: 'Product 1', price: 29.99, images: ['img1.jpg'], description: 'Description 1' },
                { id: 'prod-2', name: 'Product 2', price: 49.99, images: ['img2.jpg'], description: 'Description 2' },
                { id: 'prod-3', name: 'Product 3', price: 19.99, images: ['img3.jpg'], description: 'Description 3' }
              ],
              total: 100
            };
          }
        },
        {
          name: 'inventory',
          fetch: () => this.inventoryBreaker.execute(
            async () => {
              // Replace with actual service call
              // return await InventoryService.getBulkInventory(category, req.headers);
              
              // Mock data for example
              return {
                items: [
                  { productId: 'prod-1', quantity: 50 },
                  { productId: 'prod-2', quantity: 0 },
                  { productId: 'prod-3', quantity: 120 }
                ]
              };
            },
            () => {
              logger.warn('Inventory service unavailable, using fallback');
              return { items: [] }; // Fallback to empty if inventory service down
            }
          )
        }
      ]);

      const products = results.find(r => r.service === 'products')?.data?.items || [];
      const inventory = results.find(r => r.service === 'inventory')?.data?.items || [];
      
      // Create inventory lookup map
      const inventoryMap = new Map(inventory.map(i => [i.productId, i]));

      // Enrich products with inventory and ratings
      // Use request batcher to avoid N+1 problem when fetching ratings
      const enrichedProducts = await Promise.all(
        products.map(async product => {
          const inv = inventoryMap.get(product.id);
          
          // Batch rating requests - multiple products' ratings fetched together
          let rating = null;
          try {
            rating = await this.batcher.batch(
              'ratings',
              async (productIds) => {
                // Replace with actual service call
                // return await ReviewsService.getBulkRatings(productIds, req.headers);
                
                // Mock data for example
                return productIds.map(id => ({
                  id,
                  rating: Math.random() * 5,
                  count: Math.floor(Math.random() * 100)
                }));
              },
              product.id
            );
          } catch (error) {
            logger.warn(`Failed to fetch rating for product ${product.id}:`, error.message);
          }

          return {
            ...ResponseTransformer.pick(product, [
              'id', 'name', 'price', 'images', 'description'
            ]),
            inStock: inv?.quantity > 0 || false,
            quantity: inv?.quantity || 0,
            rating: rating ? {
              score: rating.rating.toFixed(1),
              count: rating.count
            } : null
          };
        })
      );

      const catalog = {
        products: enrichedProducts,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total: results.find(r => r.service === 'products')?.data?.total || 0
        },
        metadata: {
          category,
          inventoryAvailable: results.find(r => r.service === 'inventory')?.success || false,
          timestamp: new Date().toISOString()
        }
      };

      await this.cache.set(cacheKey, catalog, 300);
      logger.info(`Catalog cached for category ${category}`);
      
      res.json(catalog);
    } catch (error) {
      logger.error('Catalog aggregation error:', error);
      next(error);
    }
  }

  /**
   * GET /api/product/:productId
   * Get detailed product information with related products
   */
  async getProductDetails(req, res, next) {
    try {
      const { productId } = req.params;
      const cacheKey = `product:${productId}`;

      // Check cache
      const cached = await this.cache.get(cacheKey);
      if (cached) {
        return res.json(cached);
      }

      // Fetch product details and related data in parallel
      const results = await this.aggregator.fetchParallel([
        { 
          name: 'product', 
          fetch: () => this.fetchProduct(productId, req.headers) 
        },
        { 
          name: 'inventory', 
          fetch: () => this.fetchProductInventory(productId, req.headers) 
        },
        { 
          name: 'reviews', 
          fetch: () => this.fetchProductReviews(productId, req.headers) 
        },
        { 
          name: 'recommendations', 
          fetch: () => this.fetchRecommendations(productId, req.headers) 
        }
      ]);

      // Combine and transform results
      const product = results.find(r => r.service === 'product' && r.success)?.data;
      if (!product) {
        return res.status(404).json({ error: 'Product not found' });
      }

      const details = {
        ...product,
        inventory: results.find(r => r.service === 'inventory' && r.success)?.data || { inStock: false },
        reviews: results.find(r => r.service === 'reviews' && r.success)?.data || { items: [], average: 0 },
        recommendations: results.find(r => r.service === 'recommendations' && r.success)?.data || []
      };

      await this.cache.set(cacheKey, details, 300);
      res.json(details);
    } catch (error) {
      logger.error('Product details error:', error);
      next(error);
    }
  }

  /**
   * Helper methods for fetching data
   */
  async fetchProduct(productId, headers) {
    // Implement actual service call
    return { id: productId, name: 'Product', price: 99.99 };
  }

  async fetchProductInventory(productId, headers) {
    // Implement actual service call
    return { productId, inStock: true, quantity: 50 };
  }

  async fetchProductReviews(productId, headers) {
    // Implement actual service call
    return { items: [], average: 0, count: 0 };
  }

  async fetchRecommendations(productId, headers) {
    // Implement actual service call
    return [];
  }

  /**
   * GET /api/circuit-status
   * Check circuit breaker status for monitoring
   */
  async getCircuitStatus(req, res) {
    res.json({
      inventory: this.inventoryBreaker.getState(),
      batcher: this.batcher.getStats()
    });
  }
}

module.exports = new EcommerceCatalogController();

