# Gateway BFF Architecture

## Project Structure

```
gateway-bff/
├── main.go                          # Simple stub (unused)
├── cmd/
│   └── server/
│       └── main.go                  # ✅ ACTUAL SERVER (use this!)
├── internal/
│   ├── auth/
│   │   ├── secure_auth.go          # JWT authentication with encryption
│   │   └── secure_auth_test.go     # Auth tests
│   ├── aggregators/
│   │   ├── dashboard.go            # Multi-service aggregation
│   │   └── aggregators_test.go     # Aggregator tests
│   ├── health/
│   │   └── health.go               # Health check endpoints
│   └── routes/                      # Empty (routes are inline)
└── mock-services/
    ├── users/main.go                # Mock users API
    ├── analytics/main.go            # Mock analytics API
    └── notifications/main.go        # Mock notifications API
```

## Why is `internal/routes/` Empty?

**bffgen uses an inline route generation strategy.** All routes are defined directly in `cmd/server/main.go` rather than being split into separate files.

### Generated Routes Location

All 12 proxy routes are in **`cmd/server/main.go`**:

```go
// users service routes (5 endpoints)
r.Get("/api/users", createProxyHandler(...))
r.Get("/api/users/{id}", createProxyHandler(...))
r.Post("/api/users", createProxyHandler(...))
r.Put("/api/users/{id}", createProxyHandler(...))
r.Delete("/api/users/{id}", createProxyHandler(...))

// analytics service routes (3 endpoints)
r.Get("/api/analytics/metrics", createProxyHandler(...))
r.Get("/api/analytics/events", createProxyHandler(...))
r.Post("/api/analytics/events", createProxyHandler(...))

// notifications service routes (4 endpoints)
r.Get("/api/notifications", createProxyHandler(...))
r.Get("/api/notifications/{id}", createProxyHandler(...))
r.Post("/api/notifications/{id}/read", createProxyHandler(...))
r.Post("/api/notifications/read-all", createProxyHandler(...))
```

### Why This Approach?

**Pros:**

- ✅ Simple - everything in one file
- ✅ Easy to see all routes at a glance
- ✅ No import management between route files
- ✅ Less boilerplate for small projects

**Cons:**

- ❌ Can become unwieldy for large projects (100+ routes)
- ❌ Harder to organize by domain
- ❌ More merge conflicts in team environments

For this microservices gateway with 12 routes, inline generation is perfectly fine.

## Server Architecture

### 1. Entry Point: `cmd/server/main.go`

```go
func main() {
    r := chi.NewRouter()

    // Middleware stack
    r.Use(middleware.Logger)
    r.Use(middleware.Recoverer)
    r.Use(cors.Handler(...))

    // Routes (generated by bffgen)
    r.Get("/api/users", createProxyHandler(...))
    // ... more routes ...

    // Start server
    http.ListenAndServe(":8080", r)
}
```

### 2. Reverse Proxy Handler

Each route uses `createProxyHandler` which:

- Parses the backend URL
- Creates an `httputil.ReverseProxy`
- Forwards requests to the appropriate microservice
- Handles errors gracefully

```go
func createProxyHandler(backendURL, backendPath string) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        target, _ := url.Parse(backendURL)
        proxy := httputil.NewSingleHostReverseProxy(target)
        // ... proxy configuration ...
        proxy.ServeHTTP(w, r)
    }
}
```

### 3. Middleware Stack

1. **Logger** - Logs all requests
2. **Recoverer** - Catches panics
3. **CORS** - Handles cross-origin requests

### 4. Service Communication

```
Frontend (Browser)
    ↓ HTTP Request
Gateway BFF (:8080)
    ↓ Reverse Proxy
    ├─→ Users Service (:4000)
    ├─→ Analytics Service (:4001)
    └─→ Notifications Service (:4002)
```

## How to Run

### Start Mock Services

```bash
cd mock-services
./run-all-services.sh
```

### Start Gateway

```bash
# From project root
go run cmd/server/main.go
```

**Not:** `go run main.go` (that's just a stub)

### Test Endpoints

```bash
# Via Gateway
curl http://localhost:8080/api/users
curl http://localhost:8080/api/analytics/metrics
curl http://localhost:8080/api/notifications
```

## Request Flow Example

**User makes request:**

```
GET http://localhost:8080/api/users/1
```

**Gateway processes:**

1. Chi router matches route: `/api/users/{id}`
2. Calls `createProxyHandler("http://localhost:4000/api", "/users/{id}")`
3. Proxy extracts `{id}` from URL
4. Forwards to: `http://localhost:4000/api/users/1`
5. Returns response to user

## Adding New Routes

### Method 1: Edit Config and Regenerate

1. Edit `bff.config.yaml`:

```yaml
services:
  users:
    endpoints:
      - name: "search_users"
        path: "/users/search"
        method: "GET"
        exposeAs: "/api/users/search"
        authRequired: false
```

2. Regenerate:

```bash
bffgen generate
```

### Method 2: Manually Add to Server

Edit `cmd/server/main.go`:

```go
r.Get("/api/users/search", createProxyHandler(
    "http://localhost:4000/api",
    "/users/search"
))
```

## Authentication Integration

To add JWT auth to routes, modify the handler:

```go
r.Get("/api/users/{id}", authMiddleware(
    createProxyHandler("http://localhost:4000/api", "/users/{id}")
))
```

Where `authMiddleware` would use `internal/auth/secure_auth.go`.

## Aggregator Integration

For the dashboard endpoint, you'd add:

```go
r.Get("/api/dashboard", func(w http.ResponseWriter, r *http.Request) {
    baseURLs := map[string]string{
        "users":         "http://localhost:4000/api",
        "analytics":     "http://localhost:4001/api",
        "notifications": "http://localhost:4002/api",
    }

    dashboard, err := aggregators.GetDashboard("1", baseURLs)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    json.NewEncoder(w).Encode(dashboard)
})
```

## Summary

- **Routes are in `cmd/server/main.go`**, not `internal/routes/`
- Use `go run cmd/server/main.go` to start the server
- The `internal/routes/` folder exists for manual route organization (optional)
- The inline approach works well for this 12-route gateway
- Scale to separate route files if the project grows to 50+ routes
