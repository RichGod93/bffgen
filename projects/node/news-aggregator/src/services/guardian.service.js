/**
 * guardian Service
 * Auto-generated by bffgen
 *
 * Handles communication with guardian backend service
 */

const HttpClient = require("./httpClient");
const logger = require("../utils/logger");

class GuardianService {
  constructor() {
    this.baseURL =
      process.env.GUARDIAN_URL || "https://content.guardianapis.com";
    this.client = new HttpClient(this.baseURL, {
      timeout: parseInt(process.env.GUARDIAN_TIMEOUT) || 30000,
      retries: parseInt(process.env.GUARDIAN_RETRIES) || 3,
    });
  }

  /**
   * GET /search
   *
   */
  async getApiNewsGuardianHeadlines(
    params = {},
    query = {},
    body = null,
    headers = {}
  ) {
    try {
      // Build path with params
      let path = "/search";
      Object.keys(params).forEach((key) => {
        path = path.replace(`:${key}`, params[key]);
      });

      // Inject API key into query parameters
      const enrichedQuery = {
        ...query,
        "api-key": process.env.GUARDIAN_API_KEY,
      };

      // Add query string
      const queryString = new URLSearchParams(enrichedQuery).toString();
      if (queryString) {
        path += `?${queryString}`;
      }

      // Forward authorization header if present
      const requestHeaders = {};
      if (headers.authorization || headers.Authorization) {
        requestHeaders.Authorization =
          headers.authorization || headers.Authorization;
      }

      // Make request based on method
      let result;
      switch ("GET") {
        case "GET":
          result = await this.client.get(path, { headers: requestHeaders });
          break;
        case "POST":
          result = await this.client.post(path, body, {
            headers: requestHeaders,
          });
          break;
        case "PUT":
          result = await this.client.put(path, body, {
            headers: requestHeaders,
          });
          break;
        case "PATCH":
          result = await this.client.patch(path, body, {
            headers: requestHeaders,
          });
          break;
        case "DELETE":
          result = await this.client.delete(path, { headers: requestHeaders });
          break;
        default:
          throw new Error(`Unsupported HTTP method: GET`);
      }

      logger.debug(
        `guardian.getApiNewsGuardianHeadlines completed successfully`
      );
      return result;
    } catch (error) {
      logger.error(`guardian.getApiNewsGuardianHeadlines failed:`, {
        error: error.message,
        status: error.status,
        params,
        query,
      });

      // Transform backend errors to standardized format
      const serviceError = new Error(error.message || "Backend service error");
      serviceError.status = error.status || 500;
      serviceError.service = "guardian";
      serviceError.operation = "getApiNewsGuardianHeadlines";
      serviceError.originalError = error;

      throw serviceError;
    }
  }

  /**
   * GET /search
   *
   */
  async getApiNewsGuardianSearch(
    params = {},
    query = {},
    body = null,
    headers = {}
  ) {
    try {
      // Build path with params
      let path = "/search";
      Object.keys(params).forEach((key) => {
        path = path.replace(`:${key}`, params[key]);
      });

      // Inject API key into query parameters
      const enrichedQuery = {
        ...query,
        "api-key": process.env.GUARDIAN_API_KEY,
      };

      // Add query string
      const queryString = new URLSearchParams(enrichedQuery).toString();
      if (queryString) {
        path += `?${queryString}`;
      }

      // Forward authorization header if present
      const requestHeaders = {};
      if (headers.authorization || headers.Authorization) {
        requestHeaders.Authorization =
          headers.authorization || headers.Authorization;
      }

      // Make request based on method
      let result;
      switch ("GET") {
        case "GET":
          result = await this.client.get(path, { headers: requestHeaders });
          break;
        case "POST":
          result = await this.client.post(path, body, {
            headers: requestHeaders,
          });
          break;
        case "PUT":
          result = await this.client.put(path, body, {
            headers: requestHeaders,
          });
          break;
        case "PATCH":
          result = await this.client.patch(path, body, {
            headers: requestHeaders,
          });
          break;
        case "DELETE":
          result = await this.client.delete(path, { headers: requestHeaders });
          break;
        default:
          throw new Error(`Unsupported HTTP method: GET`);
      }

      logger.debug(`guardian.getApiNewsGuardianSearch completed successfully`);
      return result;
    } catch (error) {
      logger.error(`guardian.getApiNewsGuardianSearch failed:`, {
        error: error.message,
        status: error.status,
        params,
        query,
      });

      // Transform backend errors to standardized format
      const serviceError = new Error(error.message || "Backend service error");
      serviceError.status = error.status || 500;
      serviceError.service = "guardian";
      serviceError.operation = "getApiNewsGuardianSearch";
      serviceError.originalError = error;

      throw serviceError;
    }
  }
}

module.exports = GuardianService;
