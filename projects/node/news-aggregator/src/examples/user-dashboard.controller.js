/**
 * User Dashboard Aggregator Example
 * Auto-generated by bffgen
 * 
 * Demonstrates how to aggregate user data from multiple services
 * This is a complete working example - adapt to your needs
 */

const ParallelAggregator = require('../utils/aggregator');
const CacheManager = require('../utils/cache-manager');
const ResponseTransformer = require('../utils/response-transformer');
const logger = require('../utils/logger');

// Example services (replace with your actual services)
// const UserService = require('../services/user.service');
// const OrdersService = require('../services/orders.service');
// const PreferencesService = require('../services/preferences.service');

class UserDashboardController {
  constructor() {
    this.aggregator = new ParallelAggregator({ timeout: 5000, failFast: false });
    this.cache = new CacheManager({ ttl: 60, prefix: 'dashboard:' });
  }

  /**
   * GET /api/dashboard/:userId
   * Aggregates user profile, recent orders, and preferences
   */
  async getDashboard(req, res, next) {
    try {
      const userId = req.params.userId;
      
      // Check cache
      const cacheKey = `user:${userId}`;
      const cached = await this.cache.get(cacheKey);
      if (cached) {
        logger.info(`Dashboard cache hit for user ${userId}`);
        return res.json(cached);
      }

      logger.info(`Fetching dashboard data for user ${userId}`);

      // Fetch from multiple services in parallel with graceful degradation
      const results = await this.aggregator.fetchParallel([
        {
          name: 'profile',
          fetch: async () => {
            // Replace with actual service call
            // return await UserService.getProfile(userId, req.headers);
            
            // Mock data for example
            return {
              id: userId,
              name: 'John Doe',
              email: 'john@example.com',
              avatar: 'https://example.com/avatar.jpg',
              status: 'active',
              createdAt: '2024-01-01'
            };
          }
        },
        {
          name: 'recentOrders',
          fetch: async () => {
            // Replace with actual service call
            // return await OrdersService.getRecentOrders(userId, { limit: 5 }, req.headers);
            
            // Mock data for example
            return [
              { id: 'order-1', total: 99.99, status: 'delivered', date: '2024-01-15' },
              { id: 'order-2', total: 149.99, status: 'pending', date: '2024-01-20' }
            ];
          }
        },
        {
          name: 'preferences',
          fetch: async () => {
            // Replace with actual service call
            // return await PreferencesService.getUserPreferences(userId, req.headers);
            
            // Mock data for example
            return {
              theme: 'dark',
              language: 'en',
              notifications: true,
              newsletter: false
            };
          }
        }
      ]);

      // Combine results with graceful degradation
      const dashboard = {
        profile: results.find(r => r.service === 'profile' && r.success)?.data || null,
        recentOrders: results.find(r => r.service === 'recentOrders' && r.success)?.data || [],
        preferences: results.find(r => r.service === 'preferences' && r.success)?.data || {},
        timestamp: new Date().toISOString(),
        errors: results.filter(r => !r.success).map(r => ({
          service: r.service,
          error: r.error
        }))
      };

      // Transform for frontend - only send what's needed
      const transformed = {
        user: ResponseTransformer.pick(dashboard.profile, ['id', 'name', 'email', 'avatar', 'status']),
        orders: dashboard.recentOrders.map(order => 
          ResponseTransformer.pick(order, ['id', 'total', 'status', 'date'])
        ),
        settings: dashboard.preferences,
        hasErrors: dashboard.errors.length > 0
      };

      // Cache successful result
      if (dashboard.profile) {
        await this.cache.set(cacheKey, transformed, 60);
        logger.info(`Dashboard cached for user ${userId}`);
      }

      res.json(transformed);
    } catch (error) {
      logger.error('Dashboard aggregation error:', error);
      next(error);
    }
  }

  /**
   * GET /api/dashboard/:userId/full
   * Extended dashboard with additional data sources
   */
  async getFullDashboard(req, res, next) {
    try {
      const userId = req.params.userId;

      // Fetch even more services in parallel
      const results = await this.aggregator.fetchParallel([
        { name: 'profile', fetch: () => this.fetchProfile(userId, req.headers) },
        { name: 'orders', fetch: () => this.fetchOrders(userId, req.headers) },
        { name: 'preferences', fetch: () => this.fetchPreferences(userId, req.headers) },
        { name: 'recommendations', fetch: () => this.fetchRecommendations(userId, req.headers) },
        { name: 'activity', fetch: () => this.fetchActivity(userId, req.headers) }
      ]);

      // Process results
      const data = this.processResults(results);

      // Add computed fields
      const enriched = ResponseTransformer.addComputedFields(data, {
        completionScore: (d) => this.calculateCompletionScore(d),
        nextActions: (d) => this.suggestNextActions(d)
      });

      res.json(enriched);
    } catch (error) {
      logger.error('Full dashboard error:', error);
      next(error);
    }
  }

  /**
   * Process aggregation results into structured data
   */
  processResults(results) {
    return {
      profile: results.find(r => r.service === 'profile' && r.success)?.data || null,
      orders: results.find(r => r.service === 'orders' && r.success)?.data || [],
      preferences: results.find(r => r.service === 'preferences' && r.success)?.data || {},
      recommendations: results.find(r => r.service === 'recommendations' && r.success)?.data || [],
      activity: results.find(r => r.service === 'activity' && r.success)?.data || []
    };
  }

  /**
   * Helper methods for fetching data
   */
  async fetchProfile(userId, headers) {
    // Implement actual service call
    return { id: userId, name: 'User' };
  }

  async fetchOrders(userId, headers) {
    // Implement actual service call
    return [];
  }

  async fetchPreferences(userId, headers) {
    // Implement actual service call
    return {};
  }

  async fetchRecommendations(userId, headers) {
    // Implement actual service call
    return [];
  }

  async fetchActivity(userId, headers) {
    // Implement actual service call
    return [];
  }

  /**
   * Calculate profile completion score
   */
  calculateCompletionScore(data) {
    if (!data.profile) return 0;
    const fields = ['name', 'email', 'avatar', 'bio', 'phone'];
    const completed = fields.filter(f => data.profile[f]).length;
    return Math.round((completed / fields.length) * 100);
  }

  /**
   * Suggest next actions for user
   */
  suggestNextActions(data) {
    const actions = [];
    if (!data.profile?.avatar) actions.push('upload_avatar');
    if (data.orders.length === 0) actions.push('make_first_order');
    if (!data.preferences?.notifications) actions.push('enable_notifications');
    return actions;
  }
}

module.exports = new UserDashboardController();

